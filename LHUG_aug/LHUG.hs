{-# LANGUAGE DataKinds    #-}
{-# LANGUAGE PolyKinds    #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeInType   #-}

-- Csongor Kiss
-- Habito

module LHUG where
import Prelude hiding (id, undefined)

import GHC.TypeLits
import Data.Kind
























































































































































































-- Terms and types {{{1
--

five :: Int
five = 5


























































-- Naturals {{{1
data N = Z | S N
  deriving Show

two :: N
two = S (S Z)

add :: N -> N -> N
add Z n = n
add (S n) m = S (add n m)





























































-- Types and kinds {{{1
--
-- >>>> :t two
-- two :: N
-- >>>> :t N
-- ???





























































-- Promotion {{{1





























































-- Types and kinds {{{1
data N_p1 = Z_p1 | S_p1 N_p1
  deriving Show

type Two = 'S ('S 'Z)

-- Closed type family (2014)
type family Add (n :: N) (m :: N) :: N where
  Add 'Z n = n
  Add ('S n) m = 'S (Add n m)



























































-- Type families {{{1
-- Boring :: Type -> Type
type family Boring a where
  Boring String = Char
  Boring Bool   = Int





























































-- Polymorphism {{{1
type family Id a where
  Id a = a




























































-- Non-linear patterns {{{1
type family Equals (a :: k) (b :: k) :: Bool where
  Equals a a = 'True
  Equals a b = 'False




























































-- A note on arity {{{1
--
type family Arg1 (x :: Type) :: Type where
  Arg1 Int = Maybe Int
  Arg1 Bool = String
-- vs
type family Arg0 :: Type -> Type where
  Arg0 = Maybe





























































-- Parametricity? {{{1
type family Id' (a :: k) :: k where
  Id' _           = Int
  Id' x           = x

-- id :: a -> a
-- id True = False
-- id x = x




























































-- Parametricity? {{{1
-- How many implementations?
type family What :: k where
  What = Int
  What = Two
  What = Maybe




























































-- Most general kinds? {{{1
-- What's the inferred kind? What's the most general?
type family What' where
  What' = Two





























































-- CUSKs {{{1
--

type family Id'' (a :: k) :: j where
  Id'' _           = Int
  Id'' x           = x





























































-- Stuck type families {{{1
type family Stuck a where

f :: (Maybe (Stuck Bool) ~ f a) => f Int -> Maybe Int
f x = x
-- Maybe ~ f
-- Stuck Bool ~ a




























































-- Deconstructing applications {{{1






























































-- UnApply part 1 {{{1
type family UnApply1 (x :: Type) :: Type where
  UnApply1 (Maybe a)    = a
  UnApply1 (Either b a) = a
  UnApply1 ([a])        = a





























































-- UnApply part 2 {{{1
type family UnApply2 (x :: Type) :: Type where
  UnApply2 (f a) = a





























































-- UnApply part 3 {{{1
type family UnApply3 (x :: k) :: Type where
  UnApply3 (f a) = a

-- :kind! UnApply3 ('S 'Z) ?





























































-- UnApply part 4 {{{1
type family UnApply4 (x :: k) :: j where
  UnApply4 (f a) = a -- won't reduce...





























































-- Computing return kinds {{{1
type family UnApply4_p1 (x :: k) :: j where
  UnApply4_p1 (f a) = a
  UnApply4_p1 a = a

-- Dependent kinds!

type family ArgKind (x :: k) :: Type where
  ArgKind (f (a :: k)) = k
  ArgKind (a :: k) = k

type UnApply4' (x :: k) = (UnApply4 x :: ArgKind x)



























































-- Head {{{1
type family Head (x :: k) :: j where
-- :kind! Head (Either Int String)
-- Either :: Type -> Type -> Type






























































-- But wait a minute... {{{1
type family Head_p1 (x :: k) :: j where
--  Head_p1 (f a) = Head f -- pattern match on an application at _any_ kind
--  Head_p1 f     = f

-- :kind! Head' 'True
































-- How many inhabitants of Bool are there? {{{1
type family Wat (b :: Bool) :: Nat where
  Wat 'False         = 0
  Wat 'True          = 1
  Wat (f (n :: Nat)) = n











































-- Can we "fake" applications? {{{1
-- Recall:
type family Arg1_p1 (x :: Type) :: Type
-- vs
type family Arg0_p1 :: Type -> Type




























































-- Can we "fake" applications? {{{1
type family Boolish :: Nat -> Bool where
-- Boolish is stuck... no inhabitants!

-- Boolish 0
-- ^^^^^^^






































-- How many inhabitants of Bool are there? {{{1
type family Wat_p1 (b :: Bool) :: Nat where
  Wat_p1 'False = 0
  Wat_p1 'True  = 1
  Wat_p1 (_ n)  = n

-- Boolish :: Nat -> Bool
-- Wat     :: Bool -> Nat































































































-- How many inhabitants of Bool are there? {{{1
type family Boolish_p1 :: Nat -> Bool where





























































-- How many inhabitants of k are there? {{{1
type family Foolish :: Nat -> k where





























































-- How many inhabitants of k are there? {{{1
type family Wat' (b :: k) :: Nat where
  Wat' (f n)  = n
